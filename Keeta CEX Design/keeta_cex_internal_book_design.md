# Keeta CEX with Internal Orderbook Design

Here’s a compact, engineering-oriented table for a **CEX with an internal orderbook** on Keeta, including the **LP design**. I kept each row focused on “what it is”, “which Keeta primitives it uses”, “who owns it”, “how flows work”, and “safety/liveness”.

| Component / Role                     | Purpose                                        | Keeta primitives used                                                             | Ownership / Keys                                                                           | ACL settings (scope/targets)                                                                              | On-chain interactions                                                             | Off-chain logic                                                               | Failure / Liveness behavior                                                           | Security notes                                                                                   |
| ------------------------------------ | ---------------------------------------------- | --------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ |
| **User**                             | End-customer trading and withdrawing           | Keyed account; interacts with their **storage account**                           | User holds private key; is **OWNER** of their storage account (generated)                  | Optional explicit `SEND_ON_BEHALF` entry from `S_user` → user’s main wallet                               | Deposits to `S_user`; can self-withdraw anytime (OWNER)                           | Places orders; views balances; KYC flow                                       | If exchange backend is down, user still withdraws (OWNER path)                        | OWNER guarantees exit; no pooled funds trapped                                                   |
| **LP (Liquidity Provider)**          | Posts resting limit orders to provide depth    | Same as User + potentially multiple `S_user` vaults                               | LP controls own keys; same OWNER model                                                     | Same as User; may add operator `SEND_ON_BEHALF` scoped to specific **markets/tokens**                     | Funds LP’s `S_user`; withdraws profits                                            | Runs quoting logic; posts/updates limits; internal balances reserved on order | Backend outage still lets LP withdraw directly                                        | Scope operator rights per token to limit blast radius                                            |
| **Exchange Operator**                | Runs matching/settlement                       | Keyed account(s) for signing generated-account blocks; submits `SEND ON BEHALF`   | Operator keys (hot/cold); not OWNER of user vaults                                         | On each `S_user`: grant operator `SEND_ON_BEHALF` **target-scoped** (e.g., token IDs or settlement addr)  | Builds & signs blocks that move funds **from S_user** on withdrawal               | CLOB matching; risk; internal ledger; reconciliation                          | If operator goes offline, users self-withdraw; if key compromised, revoke narrow ACLs | Keep permissions minimal/specific; rotate keys by updating ACL entries (most-specific override)  |
| **User Storage Account (`S_user`)**  | Per-user vault that actually holds funds       | **Storage account** (generated); controlled via ACL                               | **OWNER = User** (generated account control by ACL; signing via permitted keyed accounts)  | Entries: (1) operator `SEND_ON_BEHALF` (scoped); (2) optional user self-withdraw entry                    | Receives deposits; origin of withdrawals                                          | —                                                                             | Survives backend failure; funds never stranded (user can move)                        | Single OWNER design avoids custody lockups                                                       |
| **Operator Settlement Account(s)**   | Netting, fee sponsorship, housekeeping         | Storage account(s) owned by operator                                              | **OWNER = Operator**                                                                       | Tightly restrict inbound/outbound targets; no user rights                                                 | Handles batched payouts, fee mgmt                                                 | Netting & treasury policies                                                   | Outage doesn’t affect user exits (since users withdraw from `S_user`)                 | Segregate hot/cold; small hot floats                                                             |
| **Token Issuer** (optional)          | Issues listed assets (stablecoin, points)      | **Token account** with **TOKEN ADMIN** (supply, per-user “use” permission)        | Issuer key(s)                                                                              | Token-level “who may use” gates (compliance)                                                              | Mint/burn; adjust balances if design requires                                     | Compliance ops; allowlists                                                    | If token restricts usage, `SEND/RECEIVE` enforce permission checks                    | Send/Receive require balance & permission validity (effects/requirements)                        |
| **Order Gateway**                    | AuthN/Z; order intake; balance holds           | — (off-chain)                                                                     | —                                                                                          | —                                                                                                         | —                                                                                 | Validates orders; reserves **internal** balances                              | Gateway outage doesn’t freeze funds                                                   | Orders are off-chain; custody is on-chain in `S_user`                                            |
| **Matching Engine (CLOB)**           | Price-time matching                            | — (off-chain)                                                                     | —                                                                                          | —                                                                                                         | — (trades don’t touch chain)                                                      | Runs books, emits fills; updates internal ledger                              | Engine down ⇒ trading halts; funds still withdrawable                                 | Classic CEX model (no on-chain AMM)                                                              |
| **Internal Ledger**                  | Source of truth for off-chain balances & fills | — (DB), but reconciled to chain                                                   | —                                                                                          | —                                                                                                         | Reads chain to reconcile; uses **fully consistent** reads for checkpoints         | Double-entry, WAL, idempotent ops                                             | Even if skew occurs, reconciliation corrects with consistent reads                    | Treat chain as custody ground-truth                                                              |
| **Settlement Orchestrator**          | Creates withdrawal transactions                | Builds blocks with `SEND` from `S_user` signed by operator (has delegated rights) | Operator signing key                                                                       | Obeys ACL scope (tokens/destinations) when constructing ops                                               | Submits `SEND`; Keeta validates **effects/requirements** (permissions, balances)  | Retry on conflict (Keeta uses optimistic concurrency; client resubmits)       | If it’s down, user can still self-withdraw                                            | Batch multiple `SEND`s per block when paying many users (flexible op list)                       |
| **Compliance / Identity** (optional) | KYC gating & policy                            | Certificates; token “use” permissions                                             | CA/issuer keys                                                                             | Vault creation can require certs; tokens may demand allowlisted certs                                     | Certs bound to keys are validated on chain                                        | KYC checks at order/deposit/withdraw time                                     | If CA offline, existing certs still verifiable                                        | Policy lives in token/ACL checks at send/receive                                                 |

---

## LP design (zoom-in)

* **Funding:** LP funds their **own** `S_user` (OWNER = LP). 
* **Posting liquidity:** LP places **limit orders** (off-chain). The gateway **reserves internal balances** against their funded `S_user`.
* **Fills:** Engine matches; internal ledger moves balances between users (no on-chain touch).
* **Exit / treasury:** LP withdraws from `S_user` at will; operator can also pay out on behalf via scoped `SEND_ON_BEHALF`.
* **Risk control:** The operator’s ACL on `S_user` is **target-scoped** (e.g., only token `USDX` or only to `addr:operator_settlement`), and can be narrowed/removed with a more-specific rule at any time (hierarchical override). 
* **Liveness:** If the operator disappears, LP self-withdraws (OWNER). If operator key is compromised, revoke its ACL entries; most-specific permissions win, so lockdown is fast.  

---

### Notes you’ll care about in implementation

* **Storage accounts** are generated accounts that “may be jointly controlled by multiple accounts by setting the ACL entries” (that’s how operator and user both have powers without changing OWNER). 
* **Effects/requirements** on `SEND/RECEIVE` enforce balances and permissions at validate/commit time—so your orchestrator should fail fast if a token’s policy blocks a move. 
* **Reads & writes:** do **fully consistent reads** for deposit crediting and EOD proofs; use OCC-style retries on conflicting writes.  

If you want, I can follow up with:

* a **canonical ACL JSON template** for `S_user` (user/LP owner, operator scoped rights), and
* a **withdrawal block skeleton** (fields/ordering) you can use as a reference for your client/orchestrator.
